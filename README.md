# With CBST Solve Shortest Paths Problem
This source code is encoded by C++ and, implemented in console platform. This solution employs the CBST as priority heap to execute the best-first-search strategy. That conducts our algorithm able to transact mega data in more high efficiency than other guys and, becomes a truly linear program to solve this problem. 

# CBST and Shortest Paths Problem
The Shortest Paths Problem is not an unsolved one, for example the Bellman-Ford method can give the correct results, but when by this way to address the big data, unless you have enough patience to wait the outcome, believe you can guess the boring. To all present-day methods, they similarly encounter this practical issue as though some alleged their own method in linear runtimes complexity.
The core strategy we still carry through is that best-first-search proposed by Gallo and Pallottino in 1988, similarly to greedy thought. The way means item can be classed by priority of weight on it to obtain the preceding for computing. 

  Naturally, this way can be achieved will depend on the management of online on data, which must be a proper one able to support that online character -- a frequency of inquiry, insertions and deletions on that database, meanwhile the database can swift provide the correct data and maintain itself at a low cost. On the other hand, this requirement is a very troublesome problem likewise to torture person nerves with volatile and dynamic quality.

  So for this reason, we invented a special database CBST or Compound Binary Search Tree (about the detail of either theory or proofs, you can read that paper whose PDF version on http://arxiv.org/abs/1810.02270) for using linked list structure as basical logical frame to construct a priority heap to condition that dynamical applicability. Our solution for this problem has bagged several algorithms in c++ class which includes HDM (Hybird Dijkstra's Method), CA (Contest Algorithm), CGSM (Card Game Sorting Method), PM (Pyramid Method). Over there can inside integrate four modules support that database: the ARA (Adjoint Reference Axis), the CL (Cousin List), the BST (Binary Search Tree) and the Flexion Accessing. Now we introduce those module files in our source code at program level.

# 1. Head File Layout:
On the level of program, the first level from system’s library – the functions' running on IO stream, which are included in head-file Exceptions_About_Memory.h, which also is defined by us to throw various information of exceptions. The second level is Auxiliary_Data_Structure.h; besides importing the fore ones, it is used to carry various data structure or data definitions for our project. The third level is head-file CBST_Tree_Company.h, which contains a CBST system and correlative a group of operations which undertake the accessing tasks and others in CBST – inquiry, deletion, insertion, looking up, sorting, construct CBST and so on. The Graph_Instance.h is the fourth level, not only to materialize instances, even more it is the major module to conduct executing algorithms for search shortest paths and finally give the precise results.

# 2. Module Introduction:
CBST_Essential_Tools.cpp the module is in use of carrying the essential operations including estimation node and its relatives, setup connections, cut-off relationships, looking up corresponding position and computing some data for one node in CBST. Those operations would be with a meta-logic character whose being executed restricted in a very narrow scope wherein there are only two items or that relationship involving to oneself circumference respectively in that four above-mentioned models.

  By whose essential tools, CBST_Tree_Basic_Operations.cpp integrates them to carry through more complicated tactics. You can learn that fact from this module: which for three sub-systems -- the ARA, the CL and the BST, they mutually support one another and harmonically to work like precise clockwork. Hence, we always gain the interest of exerting respective merits and avoiding the weakness of theirs when exercise them solely. So it aids us to reach the aim that utterly reducing the accessing cost to logarithm or constant -- deletion in O(4); insertion and inquiry both in O(log^n) and; building a proper tree in O(nlog^n). In application, the module CBST_Enumeration_Module.cpp is for the job which can take a group of cousins whom are a set of items with a same key. In that function inside, program can utilize the structure of ARA to get the minimum items one by one till all fellows off CBST; moreover, every deleting always at a constant-effort. This extraction presents a lower-cost rather than the traditional ones that by a sum of the logarithms. 
  
  Perhaps it may not be a vital improvement to whole, but that is a considerable quantity being saved for address big data in application. Since this idea, we purposely designed two versions in our source code the A version and the B version for trial to compare two ways for research algorithm. Of course, if you are interesting in survey this optimizing way, you can test it in your defined instance. 
  
  CBST_Integrated_Operations.cpp module finally continues to integrate these above modules to work as an interface of that class of CBST exposed to users for serving the task, search the shortest paths or something else. 
  
  In addition to two special modules: (1) building a proper BST, that contains two source files CBST_Sorting_Module.cpp and CBST_Tree_Building.cpp; another (2) is flexion module associating to CBST_Flexion_Module.cpp. The CBST_Sorting_Module.cpp module is easily to guess its function by file name. What about it supplies a service that can sort a stochastic sequence into an ordered one in ascent by items’ keys, an ARA, what about to expose outside as an interface; Actually, making an ARA is a key-step for bulding proper BST. It is worth to notice that amid those sorted items, the CL structure may be attached on certain member in ARA which also is a doubly-linked-list structure but every element in it with a same key we call each cousin, so the list named Cousin List only leaves an agency in ARA or BST as an item or, you can view it as an entrance of CL for visiting in ARA or CBST.  
  
  Therefore this structure on CL provides a convenience to get a whole of similar fellows for one-time instead of many-times seeking that is used in traditional way. If CBST was exercised as a priority heap, the heap always swift pop out all specified items that with a same key.
  
  Our job for building a proper BST similarly depends on that ARA. The algorithm we called Pyramid Method and those involving proofs has been introduced in that paper (http://arxiv.org/abs/1810.02270).  
  
  Alternatively in our project, the module CBST_Flexion_Module.cpp as being a special module has been used in making a random instance of weighted-graph, whose definition and calculating model likewise was introduced in above paper. That function supports the accessing with ordinal the number may be counted for item’s ranking in ARA. In that flexion model; we slightly achieve the job whereto a combinatorial problem, an allocation task: given n components each with m (n > m) rooms for residence. If we label each component with a natural number that not repetition among them, now we once again allocate those numeric into those rooms. The dispatching scheme must satisfy two conditions -- first there is not any repetition in m residing elements; second the labeling number cannot appear in its own component. This task in fact is making a connected relationship matrix in a random instance if we view those labeling number as a node in graph, those rooms for its neighbors who connect with that node.
  
  Herein, we have thin interesting to reckon the number of likelihood of allocating schemes. Our job is to make that one in which every leaf set will be randomly wadded by m natural numbers which also are those roots. We justly use the flexion system to manage the assignment task at the logarithm-coefficient runtimes. In our instance, we add another condition for yielding a simple graph: to a couple of items, both definitely are either as a root or as a leaf to each other if and only if they are connected in instance. 
The weighted-graph class is graph_instance which described in head-file Graph_Instance.h as the instance module. It contains three sub-modules: making instance; executing the Hybrid Dijkstra’s Method (HDM) and executing Contest Algorithm (CA).  

  Our program only makes three kinds of instances: the grid figure, the random figure and the complete one; over there these instances are simple ones. Of course you can define another by yourself, but truly to comply with the regulation of data structure that used to describe the connected relationship among those nodes in graph. This description is based on the arc that with an ordered pair of two nodes, whatever direction or un-direction shape, our algorithm will accept at all since our means has enough robust to address those instance. If you want to compute the multi-graph (between two nodes there can be more than one parallel arcs exist) you can use the alias to treat that case.
  
  The source-file Graph_Basic_Operations.cpp is carrying essential tools on instance; Graph_Instance.cpp module runs as the kernel engine to make three weighed-instances. It is easily to realize that the two modules Graph_HDM_Module.cpp and Graph_ContestMethod_Module.cpp respectively execute two algorithms, where we don’t plan to leave length to introduce them.

# 3. The Computing Process:
We have roughly divided a whole computing process into 10th steps. The first step is to require user input the overall parameters that including the type of instance, the range of cost where the number must be nonnegative, and up bound greater than low bound. The second step is on calling for input parameters for initializing instance according to the different type of instance. The 3rd, 4th and 5th step will yield the frame of weighted-instance, the auxiliary arrays and CBST, meanwhile initialize a CBST class. The 6th step will materialize a weighted-instance with those parameters according to the type user desire. Certainly you can define your instance by adding corresponding modules or constructing functions but remember to comply with our regulation about graph definition. To the structure carrying weights, we use the position in m room to conduct graph and weight would share their respective data. For example, the form graph[i][j] = k describes in a subgraph i is the unique root nevertheless it is the position on y-axis, also it is a root or node in instance, k is the leaf a endpoint pointed by i with arc (i, k); the j parameter is the position in leaf set the array on x-axis; it is clearly that we can utilize the vector (i, j) to access weight list correctly to fetch corresponding weight that incident to arc (i, k). 

  The 7th step is formal computing for shortest paths problem. At this step, we exercise the HDM and reckon that runtime. In those results, there two important lists worth in attention of us. One is the list Keys_list_xx which records every total weight involving to every target; another is the list Candidate whose elements are origins for next phase of search. Over there we copy them because there are two versions of algorithm in our process, the A version and the B version. The later is the optimizing version to former by directly using CL structure. 

  The 8th step is of executing the Contest Method that employs the best-first-search strategy. Through the management on those origins in use of CBST, program can undertake constant or logarithm accessing cost on that priority heap. That ever is a hard work, especially to an online character with a vast quantity of sorting, or frequently switching between offline and online. Author used a laptop with I3 dual core to address the mega data (1M nodes in grid figure, that with about 4M arcs), the practical runtime is less than 5 seconds; otherwise for a complete instance with 2k nodes and about 4M arcs likewise, the score on 0.3 second. The two results in truth reflect the difference of efforts on using CBST. 

  The 9th step is optimizing version, the B version. That distinct for two ways, is the manner of fetching those extremes. The A version adopts deleting those one by one, instead, the B version in one-time get the head of doubly-linked-list, the agency of CL and straightly through the whole. You can compare two ways by your instance. 

# The license
The Intelligent Property about this entire solution including CBST and on shortest paths problem is deserved to author in nature. It is only just for the academic application or research works, so far not in any commerce. If you intend to apply those algorithms in duplication, distribution, publishing, curriculum or teaching works; or on the other hand as a module in your software or project; please annotate clearly the reference or citation. If necessary, notice author for grant please.

Copyright (C) Yong Tan; if contect us by email: yongtan_navigation@outlook.com

